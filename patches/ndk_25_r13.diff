diff --git a/configure.py b/configure.py
index 73e124fb356..9ad16c4ba53 100644
--- a/configure.py
+++ b/configure.py
@@ -17,6 +17,7 @@
 import argparse
 import errno
 import glob
+import json
 import os
 import platform
 import re
@@ -35,9 +36,7 @@ _DEFAULT_CUDNN_VERSION = '2'
 _DEFAULT_TENSORRT_VERSION = '6'
 _DEFAULT_CUDA_COMPUTE_CAPABILITIES = '3.5,7.0'
 
-_SUPPORTED_ANDROID_NDK_VERSIONS = [
-    19, 20, 21
-]
+_SUPPORTED_ANDROID_NDK_VERSIONS = [19, 20, 21, 25]
 
 _DEFAULT_PROMPT_ASK_ATTEMPTS = 10
 
@@ -84,6 +83,10 @@ def is_ppc64le():
   return platform.machine() == 'ppc64le'
 
 
+def is_s390x():
+  return platform.machine() == 's390x'
+
+
 def is_cygwin():
   return platform.system().startswith('CYGWIN_NT')
 
@@ -488,11 +491,12 @@ def set_tf_cuda_clang(environ_cp):
       environ_cp,
       'TF_CUDA_CLANG',
       None,
-      False,
+      True,
       question=question,
       yes_reply=yes_reply,
       no_reply=no_reply,
-      bazel_config_name='cuda_clang')
+      bazel_config_name='cuda_clang',
+  )
 
 
 def set_tf_download_clang(environ_cp):
@@ -536,29 +540,6 @@ def get_from_env_or_user_or_default(environ_cp, var_name, ask_for_var,
   return var
 
 
-def set_clang_cuda_compiler_path(environ_cp):
-  """Set CLANG_CUDA_COMPILER_PATH."""
-  default_clang_path = which('clang') or ''
-  ask_clang_path = ('Please specify which clang should be used as device and '
-                    'host compiler. [Default is %s]: ') % default_clang_path
-
-  while True:
-    clang_cuda_compiler_path = get_from_env_or_user_or_default(
-        environ_cp, 'CLANG_CUDA_COMPILER_PATH', ask_clang_path,
-        default_clang_path)
-    if os.path.exists(clang_cuda_compiler_path):
-      break
-
-    # Reset and retry
-    print('Invalid clang path: %s cannot be found.' % clang_cuda_compiler_path)
-    environ_cp['CLANG_CUDA_COMPILER_PATH'] = ''
-
-  # Set CLANG_CUDA_COMPILER_PATH
-  environ_cp['CLANG_CUDA_COMPILER_PATH'] = clang_cuda_compiler_path
-  write_action_env_to_bazelrc('CLANG_CUDA_COMPILER_PATH',
-                              clang_cuda_compiler_path)
-
-
 def prompt_loop_or_load_from_env(environ_cp,
                                  var_name,
                                  var_default,
@@ -625,6 +606,29 @@ def prompt_loop_or_load_from_env(environ_cp,
   return val
 
 
+def set_clang_cuda_compiler_path(environ_cp):
+  """Set CLANG_CUDA_COMPILER_PATH."""
+  default_clang_path = '/usr/lib/llvm-16/bin/clang'
+  if not os.path.exists(default_clang_path):
+    default_clang_path = which('clang') or ''
+
+  clang_cuda_compiler_path = prompt_loop_or_load_from_env(
+      environ_cp,
+      var_name='CLANG_CUDA_COMPILER_PATH',
+      var_default=default_clang_path,
+      ask_for_var='Please specify clang path that to be used as host compiler.',
+      check_success=os.path.exists,
+      resolve_symlinks=True,
+      error_msg='Invalid clang path. %s cannot be found.',
+  )
+
+  # Set CLANG_CUDA_COMPILER_PATH
+  environ_cp['CLANG_CUDA_COMPILER_PATH'] = clang_cuda_compiler_path
+  write_action_env_to_bazelrc('CLANG_CUDA_COMPILER_PATH',
+                              clang_cuda_compiler_path)
+  return clang_cuda_compiler_path
+
+
 def create_android_ndk_rule(environ_cp):
   """Set ANDROID_NDK_HOME and write Android NDK WORKSPACE rule."""
   if is_windows() or is_cygwin():
@@ -739,29 +743,29 @@ def get_ndk_api_level(environ_cp, android_ndk_home_path):
           'another version. Compiling Android targets may result in confusing '
           'errors.\n' %
           (android_ndk_home_path, ndk_version, _SUPPORTED_ANDROID_NDK_VERSIONS))
+  write_action_env_to_bazelrc('ANDROID_NDK_VERSION', ndk_version)
 
   # Now grab the NDK API level to use. Note that this is different from the
   # SDK API level, as the NDK API level is effectively the *min* target SDK
   # version.
-  platforms = os.path.join(android_ndk_home_path, 'platforms')
-  api_levels = sorted(os.listdir(platforms))
-  api_levels = [
-      x.replace('android-', '') for x in api_levels if 'android-' in x
-  ]
-
-  def valid_api_level(api_level):
-    return os.path.exists(
-        os.path.join(android_ndk_home_path, 'platforms',
-                     'android-' + api_level))
+  meta = open(os.path.join(android_ndk_home_path, 'meta/platforms.json'))
+  platforms = json.load(meta)
+  meta.close()
+  aliases = platforms['aliases']
+  api_levels = sorted(list(set([aliases[i] for i in aliases])))
 
   android_ndk_api_level = prompt_loop_or_load_from_env(
       environ_cp,
       var_name='ANDROID_NDK_API_LEVEL',
       var_default='26',  # 26 is required to support AHardwareBuffer.
-      ask_for_var=('Please specify the (min) Android NDK API level to use. '
-                   '[Available levels: %s]') % api_levels,
-      check_success=valid_api_level,
-      error_msg='Android-%s is not present in the NDK path.')
+      ask_for_var=(
+          'Please specify the (min) Android NDK API level to use. '
+          '[Available levels: %s]'
+      )
+      % api_levels,
+      check_success=(lambda *_: True),
+      error_msg='Android-%s is not present in the NDK path.',
+  )
 
   return android_ndk_api_level
 
@@ -789,6 +793,95 @@ def set_gcc_host_compiler_path(environ_cp):
   write_action_env_to_bazelrc('GCC_HOST_COMPILER_PATH', gcc_host_compiler_path)
 
 
+def choose_compiler(environ_cp):
+  question = 'Do you want to use Clang to build TensorFlow?'
+  yes_reply = 'Clang will be used to compile TensorFlow.'
+  no_reply = 'GCC will be used to compile TensorFlow.'
+  var = int(
+      get_var(
+          environ_cp, 'TF_NEED_CLANG', None, True, question, yes_reply, no_reply
+      )
+  )
+  return var
+
+
+def set_clang_compiler_path(environ_cp):
+  """Set CLANG_COMPILER_PATH and environment variables.
+
+  Loop over user prompts for clang path until receiving a valid response.
+  Default is used if no input is given. Set CLANG_COMPILER_PATH and write
+  environment variables CC and BAZEL_COMPILER to .bazelrc.
+
+  Args:
+    environ_cp: (Dict) copy of the os.environ.
+
+  Returns:
+    string value for clang_compiler_path.
+  """
+  # Default path if clang-16 is installed by using apt-get install
+  default_clang_path = '/usr/lib/llvm-16/bin/clang'
+  if not os.path.exists(default_clang_path):
+    default_clang_path = which('clang') or ''
+
+  clang_compiler_path = prompt_loop_or_load_from_env(
+      environ_cp,
+      var_name='CLANG_COMPILER_PATH',
+      var_default=default_clang_path,
+      ask_for_var='Please specify the path to clang executable.',
+      check_success=os.path.exists,
+      resolve_symlinks=True,
+      error_msg=(
+          'Invalid clang path. %s cannot be found. Note that TensorFlow now'
+          ' requires clang to compile. You may override this behavior by'
+          ' setting TF_NEED_CLANG=0'
+      ),
+  )
+
+  write_action_env_to_bazelrc('CLANG_COMPILER_PATH', clang_compiler_path)
+  write_to_bazelrc('build --repo_env=CC=%s' % clang_compiler_path)
+  write_to_bazelrc('build --repo_env=BAZEL_COMPILER=%s' % clang_compiler_path)
+
+  return clang_compiler_path
+
+
+def retrieve_clang_version(clang_executable):
+  """Retrieve installed clang version.
+
+  Args:
+    clang_executable: (String) path to clang executable
+
+  Returns:
+    The clang version detected.
+  """
+  stderr = open(os.devnull, 'wb')
+  curr_version = run_shell([clang_executable, '--version'],
+                           allow_non_zero=True,
+                           stderr=stderr)
+
+  curr_version_split = curr_version.lower().split('clang version ')
+  if len(curr_version_split) > 1:
+    curr_version = curr_version_split[1].split()[0]
+
+  curr_version_int = convert_version_to_int(curr_version)
+  # Check if current clang version can be detected properly.
+  if not curr_version_int:
+    print('WARNING: current clang installation is not a release version.\n')
+    return None
+
+  print('You have Clang %s installed.\n' % curr_version)
+  return curr_version
+
+
+# Disable clang extension that rejects type definitions within offsetof.
+# This was added in clang-16 by https://reviews.llvm.org/D133574.
+# Can be removed once upb is updated, since a type definition is used within
+# offset of in the current version of ubp. See
+# https://github.com/protocolbuffers/upb/blob/9effcbcb27f0a665f9f345030188c0b291e32482/upb/upb.c#L183.
+def disable_clang16_offsetof_extension(clang_version):
+  if int(clang_version.split('.')[0]) == 16:
+    write_to_bazelrc('build --copt=-Wno-gnu-offsetof-extensions')
+
+
 def set_tf_cuda_paths(environ_cp):
   """Set TF_CUDA_PATHS."""
   ask_cuda_paths = (
@@ -949,8 +1042,9 @@ def set_tf_cuda_compute_capabilities(environ_cp):
 
   # Set TF_CUDA_COMPUTE_CAPABILITIES
   environ_cp['TF_CUDA_COMPUTE_CAPABILITIES'] = tf_cuda_compute_capabilities
-  write_action_env_to_bazelrc('TF_CUDA_COMPUTE_CAPABILITIES',
-                              tf_cuda_compute_capabilities)
+  write_action_env_to_bazelrc(
+      'TF_CUDA_COMPUTE_CAPABILITIES', tf_cuda_compute_capabilities
+  )
 
 
 def set_other_cuda_vars(environ_cp):
@@ -964,7 +1058,6 @@ def set_other_cuda_vars(environ_cp):
 
 def system_specific_test_config(environ_cp):
   """Add default build and test flags required for TF tests to bazelrc."""
-  write_to_bazelrc('test --flaky_test_attempts=3')
   write_to_bazelrc('test --test_size_filters=small,medium')
 
   # Each instance of --test_tag_filters or --build_tag_filters overrides all
@@ -1006,7 +1099,12 @@ def system_specific_test_config(environ_cp):
 
 
 def set_system_libs_flag(environ_cp):
+  """Set system libs flags."""
   syslibs = environ_cp.get('TF_SYSTEM_LIBS', '')
+
+  if is_s390x() and 'boringssl' not in syslibs:
+    syslibs = 'boringssl' + (', ' + syslibs if syslibs else '')
+
   if syslibs:
     if ',' in syslibs:
       syslibs = ','.join(sorted(syslibs.split(',')))
@@ -1294,14 +1392,10 @@ def main():
 
     set_tf_cuda_clang(environ_cp)
     if environ_cp.get('TF_CUDA_CLANG') == '1':
-      # Ask whether we should download the clang toolchain.
-      set_tf_download_clang(environ_cp)
-      if environ_cp.get('TF_DOWNLOAD_CLANG') != '1':
-        # Set up which clang we should use as the cuda / host compiler.
-        set_clang_cuda_compiler_path(environ_cp)
-      else:
-        # Use downloaded LLD for linking.
-        write_to_bazelrc('build:cuda_clang --config=download_clang_use_lld')
+      # Set up which clang we should use as the cuda / host compiler.
+      clang_cuda_compiler_path = set_clang_cuda_compiler_path(environ_cp)
+      clang_version = retrieve_clang_version(clang_cuda_compiler_path)
+      disable_clang16_offsetof_extension(clang_version)
     else:
       # Set up which gcc nvcc should use as the host compiler
       # No need to set this on Windows
@@ -1309,9 +1403,13 @@ def main():
         set_gcc_host_compiler_path(environ_cp)
     set_other_cuda_vars(environ_cp)
   else:
-    # CUDA not required. Ask whether we should download the clang toolchain and
-    # use it for the CPU build.
-    set_tf_download_clang(environ_cp)
+    # CUDA not required. Ask whether we should use clang for the CPU build.
+    if is_linux():
+      environ_cp['TF_NEED_CLANG'] = str(choose_compiler(environ_cp))
+      if environ_cp.get('TF_NEED_CLANG') == '1':
+        clang_compiler_path = set_clang_compiler_path(environ_cp)
+        clang_version = retrieve_clang_version(clang_compiler_path)
+        disable_clang16_offsetof_extension(clang_version)
 
   # ROCm / CUDA are mutually exclusive.
   # At most 1 GPU platform can be configured.
diff --git a/tensorflow/workspace2.bzl b/tensorflow/workspace2.bzl
index da9295adaba..40631022149 100644
--- a/tensorflow/workspace2.bzl
+++ b/tensorflow/workspace2.bzl
@@ -815,6 +815,13 @@ def _tf_repositories():
         urls = tf_mirror_urls("https://github.com/bazelbuild/rules_android/archive/v0.1.1.zip"),
     )
 
+    tf_http_archive(
+        name = "rules_android_ndk",
+        sha256 = "b29409496439cdcdb50a8e161c4953ca78a548e16d3ee729a1b5cd719ffdacbf",
+        strip_prefix = "rules_android_ndk-81ec8b79dc50ee97e336a25724fdbb28e33b8d41",
+        urls = tf_mirror_urls("https://github.com/bazelbuild/rules_android_ndk/archive/81ec8b79dc50ee97e336a25724fdbb28e33b8d41.zip"),
+    )
+
     # Apple and Swift rules.
     # https://github.com/bazelbuild/rules_apple/releases
     tf_http_archive(
diff --git a/third_party/android/android.bzl.tpl b/third_party/android/android.bzl.tpl
index e6ed4994f3b..802873f9cb4 100644
--- a/third_party/android/android.bzl.tpl
+++ b/third_party/android/android.bzl.tpl
@@ -1,3 +1,5 @@
+MAYBE_ANDROID_NDK_STARLARK_RULES
+
 """Set up configurable Android SDK and NDK dependencies."""
 
 def android_workspace():
diff --git a/third_party/android/android_configure.bzl b/third_party/android/android_configure.bzl
index 2b364118073..bd1a1933172 100644
--- a/third_party/android/android_configure.bzl
+++ b/third_party/android/android_configure.bzl
@@ -14,8 +14,9 @@
 
 _ANDROID_NDK_HOME = "ANDROID_NDK_HOME"
 _ANDROID_SDK_HOME = "ANDROID_SDK_HOME"
-_ANDROID_NDK_API_VERSION = "ANDROID_NDK_API_LEVEL"
-_ANDROID_SDK_API_VERSION = "ANDROID_SDK_API_LEVEL"
+_ANDROID_NDK_VERSION = "ANDROID_NDK_VERSION"
+_ANDROID_NDK_API_LEVEL = "ANDROID_NDK_API_LEVEL"
+_ANDROID_SDK_API_LEVEL = "ANDROID_SDK_API_LEVEL"
 _ANDROID_BUILD_TOOLS_VERSION = "ANDROID_BUILD_TOOLS_VERSION"
 
 _ANDROID_SDK_REPO_TEMPLATE = """
@@ -27,7 +28,7 @@ _ANDROID_SDK_REPO_TEMPLATE = """
     )
 """
 
-_ANDROID_NDK_REPO_TEMPLATE = """
+_ANDROID_NDK_REPO_TEMPLATE_INTERNAL = """
     native.android_ndk_repository(
         name="androidndk",
         path="%s",
@@ -35,15 +36,36 @@ _ANDROID_NDK_REPO_TEMPLATE = """
     )
 """
 
+_ANDROID_NDK_REPO_TEMPLATE_STARLARK = """
+    android_ndk_repository(
+        name="androidndk",
+        path="%s",
+        api_level=%s,
+    )
+
+    # Bind android/crosstool to support legacy select()
+    # https://github.com/bazelbuild/rules_android_ndk/issues/31#issuecomment-1396182185
+    native.bind(
+        name = "android/crosstool",
+        actual = "@androidndk//:toolchain",
+    )
+"""
+
+# Import NDK Starlark rules. Shouldn't have any indentation.
+_ANDROID_NDK_STARLARK_RULES = """
+load("@rules_android_ndk//:rules.bzl", "android_ndk_repository")
+"""
+
 def _android_autoconf_impl(repository_ctx):
     """Implementation of the android_autoconf repository rule."""
     sdk_home = repository_ctx.os.environ.get(_ANDROID_SDK_HOME)
-    sdk_api_level = repository_ctx.os.environ.get(_ANDROID_SDK_API_VERSION)
+    sdk_api_level = repository_ctx.os.environ.get(_ANDROID_SDK_API_LEVEL)
     build_tools_version = repository_ctx.os.environ.get(
         _ANDROID_BUILD_TOOLS_VERSION,
     )
     ndk_home = repository_ctx.os.environ.get(_ANDROID_NDK_HOME)
-    ndk_api_level = repository_ctx.os.environ.get(_ANDROID_NDK_API_VERSION)
+    ndk_api_level = repository_ctx.os.environ.get(_ANDROID_NDK_API_LEVEL)
+    ndk_version = int(repository_ctx.os.environ.get(_ANDROID_NDK_VERSION))
 
     sdk_rule = ""
     if all([sdk_home, sdk_api_level, build_tools_version]):
@@ -54,8 +76,13 @@ def _android_autoconf_impl(repository_ctx):
         )
 
     ndk_rule = ""
+    ndk_starlark_rules = ""
     if all([ndk_home, ndk_api_level]):
-        ndk_rule = _ANDROID_NDK_REPO_TEMPLATE % (ndk_home, ndk_api_level)
+        if ndk_version >= 25:
+            ndk_starlark_rules = _ANDROID_NDK_STARLARK_RULES
+            ndk_rule = _ANDROID_NDK_REPO_TEMPLATE_STARLARK % (ndk_home, ndk_api_level)
+        else:
+            ndk_rule = _ANDROID_NDK_REPO_TEMPLATE_INTERNAL % (ndk_home, ndk_api_level)
 
     if ndk_rule == "" and sdk_rule == "":
         sdk_rule = "pass"
@@ -68,6 +95,7 @@ def _android_autoconf_impl(repository_ctx):
         "android.bzl",
         Label("//third_party/android:android.bzl.tpl"),
         substitutions = {
+            "MAYBE_ANDROID_NDK_STARLARK_RULES": ndk_starlark_rules,
             "MAYBE_ANDROID_SDK_REPOSITORY": sdk_rule,
             "MAYBE_ANDROID_NDK_REPOSITORY": ndk_rule,
         },
@@ -76,8 +104,9 @@ def _android_autoconf_impl(repository_ctx):
 android_configure = repository_rule(
     implementation = _android_autoconf_impl,
     environ = [
-        _ANDROID_SDK_API_VERSION,
-        _ANDROID_NDK_API_VERSION,
+        _ANDROID_SDK_API_LEVEL,
+        _ANDROID_NDK_VERSION,
+        _ANDROID_NDK_API_LEVEL,
         _ANDROID_BUILD_TOOLS_VERSION,
         _ANDROID_NDK_HOME,
         _ANDROID_SDK_HOME,
